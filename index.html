<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width,initial-scale=1.0,maximum-scale=1.0,user-scalable=no">
  <title>喵了个咪</title>
  <link rel="icon" type="image/png" sizes="96x96" href="me.png">
  <!-- Preload assets -->
  <link rel="preload" href="mao3.webp" as="image">
  <link rel="preload" href="mao1.webp" as="image">
  <link rel="preload" href="https://fonts.googleapis.com/css2?family=ZCOOL+KuaiLe&display=swap" as="style">
  <link rel="preload" href="mao.webp" as="image">
  <link rel="preload" href="mao.mp4" as="video">
  <link rel="preload" href="cat1.webp" as="image">
  <link rel="preload" href="Get.mp3" as="audio">
  <link rel="preload" href="kaa.mp3" as="audio">
  <link rel="preload" href="mao2.mp4" as="video">
  <link rel="preload" href="mao2.webp" as="image">

  <!-- jQuery CDN -->
  <script src="https://ajax.googleapis.com/ajax/libs/jquery/3.7.1/jquery.min.js"></script>
  
  <!-- Google Fonts for new UI font -->
  <link rel="preconnect" href="https://fonts.googleapis.com">
  <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
  <link href="https://fonts.googleapis.com/css2?family=ZCOOL+KuaiLe&display=swap" rel="stylesheet">

  <style>
    /* CSS Variables for fonts for easier management */
    :root {
      --font-title: 'ZCOOL KuaiLe', cursive;
      --font-body: 'FangSong', 'Segoe UI', 'PingFang SC', 'Helvetica Neue', Arial, 'Microsoft Yahei', sans-serif;
      --font-special: 'HanyiSentyLotus', 'FangSong', cursive;
    }

    /* Keyframe animations */
    @keyframes card-entry {
      0% { opacity: 0; transform: scale(0.5) translateY(-50px); }
      70% { opacity: 1; transform: scale(1.05) translateY(10px); }
      100% { opacity: 1; transform: scale(1) translateY(0); }
    }

    @font-face {
        font-family: 'HanyiSentyLotus';
        src: url('https://fonts.cdnfonts.com/s/72921/hanyisentyjilian.woff') format('woff');
        font-weight: normal;
        font-style: normal;
    }
    @font-face {
        font-family: 'FangSong';
        src: local('FangSong'), local('方正仿宋简体'), local('FZFSJW');
        font-weight: normal;
        font-style: normal;
    }
    @keyframes pulse-scale {
      0%, 100% { transform: scale(1); opacity: 0.8; }
      50% { transform: scale(1.05); opacity: 1; }
    }
    @keyframes text-progress {
      0% { content: "."; }
      33% { content: ".."; }
      66% { content: "..."; }
      100% { content: "."; }
    }
    @keyframes wave {
      0%, 100% { transform: translateY(0) rotate(0deg); }
      25% { transform: translateY(-10px) rotate(2deg); }
      75% { transform: translateY(5px) rotate(-1deg); }
    }
    @keyframes show-card-property {
      0% { opacity: 0; }
      20% { opacity: 1; }
      80% { opacity: 1; }
      100% { opacity: 0; }
    }
    @keyframes fade-in-out-scale {
      0% { opacity: 0; transform: scale(0.8); }
      50% { opacity: 1; transform: scale(1); }
      100% { opacity: 0; transform: scale(0.9); }
    }
    @keyframes shake {
      0%, 100% { transform: translateX(0) rotate(0deg); }
      10%, 30%, 50%, 70%, 90% { transform: translateX(-3px) rotate(-1deg); }
      20%, 40%, 60%, 80% { transform: translateX(3px) rotate(1deg); }
    }
    @keyframes score-pop {
      0% { opacity: 0; transform: translateY(0) scale(0.8); }
      20% { opacity: 1; transform: translateY(-15px) scale(1.1); }
      80% { opacity: 1; transform: translateY(-30px) scale(1); }
      100% { opacity: 0; transform: translateY(-40px) scale(0.7); }
    }
    .score-animation {
      position: absolute;
      font-size: clamp(1.2rem, 3vw, 1.5rem);
      font-weight: bold;
      color: #4CAF50;
      text-shadow: 1px 1px 2px rgba(0,0,0,0.3);
      pointer-events: none;
      animation: score-pop 1s ease-out forwards;
      z-index: 2000;
    }
    @keyframes card-shuffle-out {
      0% { opacity: 1; transform: scale(1) rotate(0deg); }
      50% { opacity: 0; transform: scale(0.5) rotate(15deg); }
      100% { opacity: 0; transform: scale(0.5) rotate(15deg); }
    }
    .card-shuffling-out {
      animation: card-shuffle-out 0.3s ease-in forwards;
    }
    @keyframes fade-in-out-heart {
      0% { opacity: 0; transform: scale(0.5); }
      50% { opacity: 1; transform: scale(1.2); }
      100% { opacity: 0; transform: scale(0.8); }
    }
    .heart-animation {
      position: absolute;
      font-size: 30px;
      color: #ff69b4;
      pointer-events: none;
      animation: fade-in-out-heart 2.5s ease-out infinite alternate;
      z-index: 1000;
      text-shadow: 1px 1px 3px rgba(0,0,0,0.2);
    }

    /* Global body styles */
    body {
      margin: 0;
      min-height: 100vh;
      overflow-x: hidden;
      font-family: var(--font-body);
      color: #3e2723;
      position: relative;
    }
    body::before {
      content: "";
      position: absolute;
      top: 0; left: 0; width: 100%; height: 100%;
      background: #f7f0e8 url('cat1.webp') no-repeat center center fixed;
      background-size: cover;
      z-index: -2;
    }
    body::after {
      content: "";
      position: absolute;
      top: 0; left: 0; width: 100%; height: 100%;
      background-color: white;
      opacity: 0.3;
      z-index: -1;
    }
    body.no-scroll {
      overflow: hidden;
    }

    /* Game Container */
    #game-container {
      max-width: 650px;
      margin: 30px auto;
      background: rgba(255, 255, 255, 0.7);
      border-radius: 25px;
      box-shadow: 0 5px 25px rgba(100, 60, 40, 0.3);
      padding: 0 0 20px 0;
      position: relative;
      min-height: 880px;
      display: flex;
      flex-direction: column;
      align-items: center;
      border: 3px solid #8B4513;
    }
    @media (max-width: 700px) {
      #game-container {
        max-width: 100vw;
        margin: 0;
        box-shadow: none;
        border-radius: 0;
        min-height: 100vh;
        border: none;
        padding-top: env(safe-area-inset-top);
        padding-bottom: env(safe-area-inset-bottom);
      }
    }
    @media (min-width: 701px) {
      #game-container {
        max-width: 900px;
        min-height: 90vh;
        margin: 5vh auto;
      }
    }

    /* Header Bar */
    #header-bar {
      width: 100%;
      padding: 15px 25px 0 25px;
      box-sizing: border-box;
      display: flex;
      justify-content: space-between;
      align-items: center;
      background: linear-gradient(to bottom, rgba(255,255,255,0.8), rgba(255,255,255,0));
      border-top-left-radius: 22px;
      border-top-right-radius: 22px;
    }
    #progress-info {
      font-size: clamp(1rem, 4vw, 1.55rem); /* Responsive Font */
      font-weight: bold;
      color: #5d4037;
      text-shadow: 0.5px 0.5px 0 rgba(255,255,255,0.7);
      display: flex;
      gap: 15px;
      align-items: center;
      flex-wrap: wrap; /* Allow wrapping on small screens */
    }
    #music-toggle {
      background: none;
      border: none;
      outline: none;
      font-size: clamp(1.5rem, 5vw, 1.8rem); /* Responsive Font */
      cursor: pointer;
      color: #6d4c41;
      transition: transform 0.2s ease-in-out;
    }
    #music-toggle:hover {
      transform: scale(1.1);
    }
    .score-display, .target-display {
        font-size: clamp(0.9rem, 3vw, 1.2rem); /* Responsive Font */
        color: #8B4513;
        font-weight: bold;
        text-shadow: 0.5px 0.5px 0 rgba(255,255,255,0.7);
    }

    /* Main Game Area */
    #main-area {
      flex:1;
      width: 100%;
      display: flex;
      flex-direction: column;
      align-items: center;
      justify-content: flex-start;
      position: relative;
      padding-top: 10px;
    }

    /* Display Area */
    #display-area {
        margin-top: 20px;
        width: 90%;
        max-width: 580px;
        min-height: 100px;
        background: rgba(240, 230, 210, 0.6);
        border-radius: 15px;
        box-shadow: inset 0 2px 10px rgba(100, 60, 40, 0.15), 0 5px 15px rgba(100, 60, 40, 0.2);
        display: flex;
        flex-direction: row;
        flex-wrap: wrap;
        justify-content: center;
        align-items: center;
        border: 2px dashed #b8860b;
        padding: 10px;
        box-sizing: border-box;
        gap: 10px;
    }
    @media (max-width: 650px) {
      #display-area {
        width: 96vw;
        min-width: unset;
        min-height: 80px;
      }
    }

    .display-group {
        display: flex;
        gap: 5px;
        align-items: center;
        justify-content: center;
        background: rgba(255, 255, 255, 0.5);
        border-radius: 8px;
        padding: 5px 10px;
        border: 1px solid #d4a762;
    }
    .display-card {
        background: #fffdf7;
        border-radius: 8px;
        box-shadow: 0 2px 8px rgba(0,0,0,0.1);
        border: 2px solid #a0522d;
        display: flex;
        align-items: center;
        justify-content: center;
        user-select: none;
        opacity: 1;
        transition: opacity 0.3s ease-out;
    }
    .display-card.matched-display {
        opacity: 0;
    }

    /* Cat Animation Path */
    #cat-path {
        position: absolute;
        width: 100%;
        height: 20px;
        left: 0;
        z-index: 1000;
        pointer-events: none;
        overflow: visible;
    }
    @keyframes cat-walk {
        0% { left: 0; }
        100% { left: calc(100% - 55px); }
    }
    #walking-cat {
        position: absolute;
        width: 40px;
        height: 40px;
        font-size: 40px;
        line-height: 1;
        display: flex;
        z-index: 10;
        align-items: center;
        justify-content: center;
        color: #5d4037;
        top: -20px;
        transform: scaleX(1);
        transition: transform 0.01s linear, opacity 0.01s linear;
        animation: cat-walk 10s linear infinite alternate;
    }

    /* Wiggling Cat Instances */
    .wiggling-cat-instance {
        position: absolute;
        width: 35px;
        height: 35px;
        font-size: 35px;
        line-height: 1;
        display: flex;
        align-items: center;
        justify-content: center;
        color: #5d4037;
        transform: translateX(-50%);
        animation: shake 1.8s ease-in-out infinite alternate;
        z-index: 10;
        pointer-events: none;
        display: none;
    }

    /* Card Stack Area */
    #card-stack-area {
      margin-top: 20px;
      width: 90%;
      max-width: 580px;
      height: 500px;
      position: relative;
      background: rgba(240, 230, 210, 0.6);
      border-radius: 15px;
      box-shadow: inset 0 2px 10px rgba(100, 60, 40, 0.15), 0 5px 15px rgba(100, 60, 40, 0.2);
      overflow: visible;
      display: flex;
      align-items: center;
      justify-content: center;
      border: 2px dashed #b8860b;
    }
    @media (max-width: 650px) {
      #card-stack-area {
        width: 96vw;
        min-width: unset;
        height: 60vh;
        max-height: 420px;
        margin-top: 15px;
        margin-bottom: 15px;
      }
    }
    @media (min-width: 701px) {
      #card-stack-area {
        height: 600px;
        max-height: 60vh;
      }
    }

    /* Individual Card Styles */
    .card {
      background: #fffdf7;
      border-radius: 10px;
      box-shadow: 0 4px 15px rgba(0,0,0,0.1), inset 0 0 0 1px rgba(255,255,255,0.5);
      border: 3px solid #d4a762;
      position: absolute;
      display: flex;
      align-items: center;
      justify-content: center;
      cursor: pointer;
      user-select: none;
      transition: transform 0.15s ease-out, box-shadow 0.15s ease-out, opacity 0.3s, border-color 0.15s;
      z-index: 1;
      overflow: hidden;
      color: #5d4037;
      -webkit-user-select: none;
      -moz-user-select: none;
      -ms-user-select: none;
    }
    .card-entering {
      animation: card-entry 0.5s ease-out forwards;
    }
    .hint-animation {
      animation: show-card-property 2s forwards;
    }
    .card.selected {
      border: 3.5px solid #a0522d;
      box-shadow: 0 4px 20px rgba(160, 82, 45, 0.4), 0 0 25px rgba(255,255,0,0.5);
      z-index: 100 !important;
      transform: scale(1.01) rotate(-2deg);
    }
    .card.disabled {
      pointer-events: none;
      position: absolute;
      opacity: 1;
    }
    .card.disabled::before {
      content: '';
      position: absolute;
      top: 0; left: 0; width: 100%; height: 100%;
      background: rgba(128, 128, 128, 0.4);
      border-radius: 8px;
      z-index: 2;
      transition: background 0.5s ease;
    }
    .card.disabled > *:not(.disabled::before) {
        opacity: 0.5;
    }
    .card:not(.disabled):not(.matched):hover {
      transform: translateY(-5px) scale(1.05) rotate(2deg);
      box-shadow: 0 8px 20px rgba(0,0,0,0.15), inset 0 0 0 1px rgba(255,255,255,0.5);
      transition: transform 0.1s ease-out, box-shadow 0.05s ease-out;
      z-index: 2;
    }
    .card.matched {
      opacity: 0.05;
      transition: opacity 0.2s;
      pointer-events: none;
    }
    .card .mini {
      font-size: 1.2rem;
      position: absolute;
      bottom: 7px;
      right: 9px;
      opacity: 0.5;
      user-select: none;
    }
    .card.napping {
        pointer-events: none !important;
    }
    .card.napping::after {
        content: '💤';
        position: absolute;
        top: -10px;
        right: -5px;
        font-size: 1.5rem;
        animation: wave 1.5s infinite ease-in-out;
        z-index: 5;
    }
    .card.napping::before {
        background: rgba(100, 100, 150, 0.3) !important;
    }

    /* Temporary Area (Temp Slot) */
    #temp-area {
      margin: 20px auto 0 auto;
      display: flex;
      justify-content: space-evenly;
      align-items: center;
      min-height: 80px;
      width: 90%;
      max-width: 500px;
      border-radius: 12px;
      background: #fffcf0;
      border: 2px dashed #b8860b;
      padding: 8px 0;
      box-sizing: border-box;
      box-shadow: inset 0 1px 5px rgba(0,0,0,0.08);
    }
    .temp-slot {
      margin: 0;
      background: #fdf5e6;
      border-radius: 9px;
      border: 2px dashed #d4a762;
      display: flex;
      align-items: center;
      justify-content: center;
      color: #92776c;
      box-shadow: inset 0 1px 4px rgba(0,0,0,0.05);
      position: relative;
      overflow: hidden;
      flex-shrink: 0;
    }
    .temp-card {
      width: 100%;
      height: 100%;
      background: #fffdf7;
      border-radius: 9px;
      border: 2.5px solid #a0522d;
      display: flex;
      align-items: center;
      justify-content: center;
      box-shadow: 0 2px 8px rgba(160, 82, 45, 0.3);
      cursor: default;
      position: absolute;
      transition: opacity 0.2s, border-color 0.2s, box-shadow 0.2s;
      box-sizing: border-box;
      color: #5d4037;
    }
    .temp-card.matched {
      opacity: 0.05;
    }

    /* Flying Card Animation */
    .flying-card {
      background: #fffdf7;
      border-radius: 10px;
      box-shadow: 0 4px 15px rgba(0,0,0,0.1), inset 0 0 0 1px rgba(255,255,255,0.5);
      border: 3px solid #d4a762;
      position: fixed;
      display: flex;
      align-items: center;
      justify-content: center;
      user-select: none;
      z-index: 10000;
      transition: top 0.3s ease-in-out, left 0.3s ease-in-out, transform 0.3s ease-in-out;
      overflow: hidden;
      color: #5d4037;
    }

    /* Tools Bar */
    #tools-bar {
      margin: 20px auto 0 auto;
      display: flex;
      align-items: center;
      justify-content: center;
      gap: 18px;
      width: 90%;
      max-width: 500px;
      flex-wrap: wrap;
    }
    #tools-bar button {
      padding: 9px 18px;
      background: #f7e9d7;
      border: 2px solid #b8860b;
      border-radius: 10px;
      font-size: clamp(0.9rem, 3vw, 1.05rem); /* Responsive Font */
      font-family: var(--font-title);
      color: #6e352f;
      font-weight: bold;
      cursor: pointer;
      transition: background 0.15s, transform 0.1s;
      outline: none;
      position: relative;
      min-width: 75px;
      box-shadow: 0 2px 6px rgba(0,0,0,0.1);
    }
    #tools-bar button:hover {
      background: #e9d9c6;
      transform: translateY(-1px);
    }
    #tools-bar button:disabled {
      background: #f0f0f0;
      color: #b0b0b0;
      border-color: #d0d0d0;
      cursor: not-allowed;
      transform: none;
      box-shadow: none;
    }
    #restart-btn {
      background: #ffe0b3;
      border-color: #ffcc80;
      color: #96602c;
    }
    #restart-btn:hover {
      background: #ffd599;
    }

    /* Code Redemption Bar */
    #code-bar {
      margin: 15px auto 0 auto;
      display: flex;
      align-items: center;
      justify-content: center;
      gap: 8px;
      width: 90%;
      max-width: 450px;
    }
    #code-bar input {
      flex-grow: 1;
      max-width: 180px;
      padding: 7px 10px;
      border-radius: 8px;
      border: 2px solid #b8860b;
      outline: none;
      font-size: clamp(0.9rem, 3vw, 1.05rem); /* Responsive Font */
      color: #5d4037;
      background: #fffdf7;
      box-shadow: inset 0 1px 3px rgba(0,0,0,0.1);
    }
    #code-bar input::placeholder {
      color: #a0a0a0;
    }
    #code-bar button {
      padding: 7px 12px;
      font-size: clamp(0.9rem, 3vw, 1.05rem); /* Responsive Font */
      font-family: var(--font-title);
      background: #e6f6d3;
      border: 2px solid #a0c388;
      border-radius: 9px;
      cursor: pointer;
      color: #3e5a2b;
      font-weight: bold;
      transition: background 0.15s;
      min-width: 65px;
      box-shadow: 0 1px 4px rgba(0,0,0,0.1);
    }
    #code-bar button:hover {
      background: #d2e5bb;
    }

    /* Message Bar */
    #message-bar {
      margin: 15px auto 0 auto;
      text-align: center;
      font-size: clamp(0.9rem, 3.5vw, 1.1rem); /* Responsive Font */
      color: #c0392b;
      min-height: 28px;
      font-weight: bold;
      letter-spacing: 1.2px;
    }

    /* Random Event Message Overlay */
    #event-overlay {
        position: absolute;
        top: 0; left: 0; width: 100%; height: 100%;
        display: none;
        align-items: center;
        justify-content: center;
        z-index: 2200;
        pointer-events: none;
    }
    #event-message-box {
        background: rgba(255, 253, 247, 0.9);
        padding: 20px 30px;
        border-radius: 15px;
        border: 3px solid #b8860b;
        box-shadow: 0 5px 20px rgba(0,0,0,0.2);
        text-align: center;
        animation: fade-in-out-scale 3.5s forwards;
    }
    #event-message-box p {
        font-size: clamp(1rem, 4vw, 1.3rem); /* Responsive Font */
        color: #6e352f;
        margin: 0;
        font-weight: bold;
        text-shadow: 1px 1px 0 rgba(255,255,255,0.5);
    }
    #event-message-box .event-icon {
        font-size: clamp(1.5rem, 5vw, 2rem); /* Responsive Font */
        margin-bottom: 10px;
    }

    /* Overlay Screens (Start, Level Finish, Game Over) */
    #start-screen, #level-finish, #game-over {
      position: absolute;
      left: 0; right: 0; top: 0; bottom: 0;
      z-index: 1100;
      background: rgba(255,255,255,0.98);
      display: flex;
      align-items: center;
      justify-content: center;
      flex-direction: column;
      font-size: clamp(1rem, 3vw, 1.1rem); /* Responsive Font */
      border-radius: 25px;
      text-align: center;
    }
    #start-screen {
      padding-top: 10vh;
      overflow: hidden;
      box-sizing: border-box;
    }
    #start-screen-video {
        position: absolute;
        top: 50%; left: 50%;
        transform: translate(-50%, -50%);
        min-width: 100%; min-height: 100%;
        width: auto; height: auto;
        z-index: -1;
        opacity: 0.99;
        object-fit: cover; 
    }
    #start-screen::before {
      content: "";
      position: absolute;
      left: 0; right: 0; top: 0; bottom: 0;
      background-image: url('mao.webp');
      background-size: cover;
      background-position: center;
      opacity: 0.5;
      z-index: -2;
    }
    #start-screen h1 {
      font-family: var(--font-title);
      font-size: clamp(3rem, 12vw, 5rem); /* Responsive Title */
      margin: 0 0 25px 0;
      letter-spacing: 3px;
      text-shadow: 2px 2px 0 #f7e9d7, 4px 4px 0 #b8860b, 6px 6px 8px rgba(0,0,0,0.2); /* Enhanced Shadow */
      display: inline-block;
      color: #8B4513;
    }
    #start-screen h1 span {
      display: inline-block;
      animation: wave 2s infinite ease-in-out;
    }
    #start-screen h1 span:nth-child(1) { animation-delay: -0.4s; }
    #start-screen h1 span:nth-child(2) { animation-delay: -0.2s; }
    #start-screen h1 span:nth-child(3) { animation-delay: 0s; }
    #start-screen h1 span:nth-child(4) { animation-delay: 0.2s; }
    #start-screen h1 span:nth-child(5) { animation-delay: 0.4s; }
    #start-screen .start-btn {
      margin-top: 30px;
      padding: 15px 50px;
      font-size: clamp(1.2rem, 4vw, 1.5rem); /* Responsive Font */
      font-family: var(--font-title);
      background: linear-gradient(90deg, #a0c388, #88b368);
      border: none;
      border-radius: 15px;
      color: white;
      text-shadow: 1px 1px 2px rgba(0,0,0,0.3);
      font-weight: bold;
      cursor: pointer;
      box-shadow: 0 4px 15px rgba(160, 195, 136, 0.5);
      animation: pulse-scale 1.5s infinite ease-in-out;
      transition: background 0.2s, transform 0.1s;
    }
    #start-screen .start-btn:hover {
      background: linear-gradient(90deg, #88b368, #a0c388);
      transform: translateY(-2px);
    }
    #start-screen p {
        color: #5d4037;
        line-height: 1.6;
        margin: 0 40px 15px;
        margin-top: 15vh;
    }
    #start-screen span {
        color: #c0392b;
        font-weight: bold;
    }

    /* Footer for loading and start screens */
    .loading-footer {
        color: #795548;
        font-size: clamp(0.75rem, 2.5vw, 0.85rem); /* Responsive Font */
        position: absolute;
        bottom: 30px;
        left: 0;
        right: 0;
        text-align: center;
        font-family: var(--font-special);
        letter-spacing: 1.5px;
        text-shadow: 0.5px 0.5px 0 rgba(255,255,255,0.5);
    }

    /* Level Finish and Game Over Screens */
    #level-finish, #game-over {
      font-size: clamp(1.2rem, 5vw, 1.8rem); /* Responsive Font */
      font-family: var(--font-body);
      color: #5d4037;
      background: rgba(255,243,245,0.99);
      border-radius: 25px;
      position: absolute;
      overflow: hidden;
      border: 3px solid #8B4513;
      box-shadow: 0 5px 25px rgba(100, 60, 40, 0.3);
    }
    #game-over {
      animation: wave 2s infinite;
    }
    #level-finish::before, #game-over::before {
      content: "";
      position: absolute;
      left: 0; right: 0; top: 0; bottom: 0;
      background-image: url('mao1.webp');
      background-size: cover;
      background-position: center;
      opacity: 0.4;
      z-index: -1;
    }
    #level-finish button, #game-over button {
      margin-top: 25px;
      padding: 12px 35px;
      font-size: clamp(1rem, 4vw, 1.25rem); /* Responsive Font */
      font-family: var(--font-title);
      background: #e6f6d3;
      border: 2px solid #a0c388;
      border-radius: 12px;
      color: #3e5a2b;
      font-weight: bold;
      cursor: pointer;
      transition: background 0.15s, transform 0.1s;
      box-shadow: 0 2px 8px rgba(0,0,0,0.1);
    }
    #level-finish button:hover, #game-over button:hover {
      background: #d2e5bb;
      transform: translateY(-1px);
    }
    #retry-btn {
      margin-top: 18px;
      padding: 10px 30px;
      font-size: clamp(0.9rem, 3.5vw, 1.15rem); /* Responsive Font */
      background: #f7e9d7;
      border: 2px solid #d4a762;
      border-radius: 10px;
      color: #6e352f;
      font-weight: bold;
      cursor: pointer;
      transition: background 0.15s, transform 0.1s;
      display: inline-block;
      box-shadow: 0 1px 5px rgba(0,0,0,0.1);
    }
    #retry-btn:hover {
      background: #f0e1d0;
      transform: translateY(-1px);
    }

    /* Main Game Footer */
    #footer {
      margin: 20px auto 0 auto;
      width: 100%;
      text-align: center;
      font-size: clamp(0.8rem, 3vw, 1rem); /* Responsive Font */
      color: #8B4513;
      font-family: var(--font-special);
      letter-spacing: 1.5px;
      text-shadow: 0.5px 0.5px 0 rgba(255,255,255,0.5);
    }

    /* Hint Animation */
    .hinted-shake {
      animation: shake 0.5s ease-in-out 4;
    }

    /* Custom Confirm Modal Styles */
    .modal-overlay {
        position: fixed;
        top: 0; left: 0; width: 100%; height: 100%;
        background: rgba(0,0,0,0.6);
        z-index: 2500;
        display: none;
        align-items: center;
        justify-content: center;
    }
    .modal-content {
        background: #fffdf7;
        padding: 30px 40px;
        border-radius: 15px;
        text-align: center;
        box-shadow: 0 5px 20px rgba(0,0,0,0.3);
        border: 3px solid #d4a762;
    }
    .modal-content p {
        font-size: clamp(1rem, 4vw, 1.2rem); /* Responsive Font */
        color: #5d4037;
        margin: 0 0 25px 0;
        font-weight: bold;
    }
    .modal-content button {
        padding: 9px 25px;
        background: #f7e9d7;
        border: 2px solid #b8860b;
        border-radius: 10px;
        font-size: clamp(0.9rem, 3vw, 1.05rem); /* Responsive Font */
        font-family: var(--font-title);
        color: #6e352f;
        font-weight: bold;
        cursor: pointer;
        margin: 0 10px;
        transition: background 0.15s, transform 0.1s;
    }
    #confirm-yes {
        background: #e6f6d3;
        border-color: #a0c388;
        color: #3e5a2b;
    }
    #confirm-yes:hover {
        background: #d2e5bb;
    }
    #confirm-no:hover {
        background: #e9d9c6;
    }

    /* Level Finish Text */
    #level-finish-text {
      font-family: var(--font-body);
      color: #3e2723;
      font-size: clamp(1rem, 4vw, 1.2em); /* Responsive Font */
      text-align: center;
      margin-bottom: 20px;
    }

    /* Loading Screen Styles */
    #loading-screen {
      position: absolute;
      top: 0; left: 0; width: 100%; height: 100%;
      z-index: 1199;
      display: flex;
      align-items: center;
      justify-content: center;
      background-color: #f7f0e8;
      background-size: cover;
      transition: opacity 0.5s ease-out;
      border-radius: 25px;
      overflow: hidden;
    }
    #loading-screen::before {
      content: '';
      position: absolute;
      top: 0; left: 0; width: 100%; height: 100%;
      background-image: url('mao3.webp');
      background-repeat: no-repeat;
      background-position: center center;
      background-size: cover;
      opacity: 0.6;
    }
    .loading-content {
      position: relative;
      z-index: 1001;
      text-align: center;
      width: 80%;
      max-width: 500px;
      display: flex;
      flex-direction: column;
      height: 100%;
      align-items: center;
      justify-content: flex-start;
      padding-top: 6vh;
      box-sizing: border-box;
    }
    .loading-title {
      font-size: clamp(2rem, 8vw, 2.8rem); /* Responsive Font */
      margin: 0 0 40px 0;
      font-family: var(--font-title);
      color: #3e2723;
      letter-spacing: 3px;
      text-shadow: 2px 2px 0 #f7e9d7, 4px 4px 0 #b8860b;
      animation: pulse-scale 1.5s infinite ease-in-out;
    }
    .loading-title::after {
      content: ".";
      animation: text-progress 2s infinite;
    }
    .progress-bar-container {
      width: 100%;
      height: 30px;
      background: rgba(184, 134, 11, 0.2);
      border-radius: 10px;
      border: 2px solid #b8860b;
      overflow: hidden;
      margin-bottom: 15px;
      box-shadow: inset 0 1px 3px rgba(0,0,0,0.1);
      margin-top: 40vh;
      z-index: 1004;
    }
    #progress-bar {
      width: 0%;
      height: 100%;
      background: linear-gradient(90deg, #a0c388, #88b368);
      border-radius: 8px;
      transition: width 0.3s ease-out;
    }
    #loading-text {
      font-size: clamp(0.9rem, 3.5vw, 1.1rem); /* Responsive Font */
      color: #5d4037;
      margin-bottom: 40px;
      min-height: 20px;
      text-align: center;
    }

    /* Responsive Video Container */
    .responsive-video-container {
        position: relative;
        width: 100%;
        max-width: 660px;
        padding-bottom: 68.1818%;
        height: 0;
        overflow: hidden;
        border-radius: 10px;
        box-shadow: 0 4px 8px rgba(0, 0, 0, 0.1);
    }
    .responsive-video-container iframe {
        position: absolute;
        top: 0; left: 0; width: 100%; height: 100%;
        border: 0;
        border-radius: 10px;
    }

    /* Level 2 Outro Screen */
    #level2-outro-screen {
        position: absolute;
        top: 0; left: 0; width: 100%; height: 100%;
        background-color: rgba(0, 0, 0, 0.9);
        z-index: 2000;
        display: none;
        flex-direction: column;
        align-items: center;
        justify-content: center;
        border-radius: 25px;
        overflow: hidden;
    }
    #level2-outro-screen video, #level2-outro-screen img {
        position: absolute;
        top: 50%; left: 50%;
        transform: translate(-50%, -50%);
        min-width: 100%; min-height: 100%;
        width: auto; height: auto;
        object-fit: cover;
        border-radius: 0;
        box-shadow: none;
    }
    #level2-outro-screen .loading-text {
        color: white;
        font-size: clamp(1.2rem, 4vw, 1.5rem); /* Responsive Font */
        margin-top: 20px;
    }
    #skip-outro-btn {
        position: absolute;
        top: 20px; right: 20px;
        padding: 8px 15px;
        background: rgba(255, 255, 255, 0.7);
        border: 1px solid #ccc;
        border-radius: 8px;
        font-size: clamp(0.8rem, 3vw, 1rem); /* Responsive Font */
        color: #333;
        cursor: pointer;
        z-index: 2001;
        transition: background 0.2s, transform 0.2s;
    }
    #skip-outro-btn:hover {
        background: rgba(255, 255, 255, 0.9);
        transform: scale(1.05);
    }

    /* Media Queries for smaller screens */
    @media (max-width: 500px) {
      #card-stack-area, #temp-area, #tools-bar, #code-bar { width: 98vw; }
      #tools-bar button {
          min-width: unset;
          width: 30%;
          margin-bottom: 8px;
          padding: 8px 10px;
      }
      #tools-bar {
          gap: 6px;
      }
      #temp-area {
        width: 98vw;
        margin: 15px auto 0 auto;
      }
      .temp-slot {
        width: 12vw;
        height: 16vw;
      }
      .temp-card {
        font-size: 6vw;
      }
      #code-bar input {
        width: 50%;
      }
      #display-area {
        width: 96vw;
        padding: 5px;
      }
      .display-card {
        width: 10vw;
        height: 13vw;
        font-size: 4.5vw;
      }
      #level-finish, #game-over {
        padding: 20px;
        box-sizing: border-box;
      }
    }
  </style>
  <!-- The external CSS files are not strictly necessary as styles are inlined, but kept for reference -->
  <link rel="stylesheet" href="font/iconfont.css">
  <link rel="stylesheet" href="css/style.css">
</head>
<body>
<div id="game-container">
  <div id="loading-screen">
    <div class="loading-content">
      <h1 class="loading-title">Loading.</h1>
      <div class="progress-bar-container">
        <div id="progress-bar"></div>
      </div>
      <p id="loading-text">正在加载资源...</p>
      <small class="loading-footer">喵了个咪 &copy 2025 | Designed by 开元</small>
    </div>
  </div>

  <div id="header-bar">
    <div id="progress-info">
        <span id="level-info">关卡: 1 / 2</span>
        <span class="score-display">分数: <span id="current-score">0</span></span>
        <span class="target-display">目标: <span id="target-score">0</span></span>
    </div>
    <button id="music-toggle" title="音乐开关">🎼</button>
  </div>
  <div id="main-area">
    <div id="display-area"></div>
    <div id="cat-path">
        <div id="walking-cat">🐈</div>
    </div>
    <div id="card-stack-area"></div>
    <div id="wiggling-cat-1" class="wiggling-cat-instance">🥳</div>
    <div id="wiggling-cat-4" class="wiggling-cat-instance">🎉</div>
    <div id="wiggling-cat-7" class="wiggling-cat-instance">🍻</div>

    <div id="temp-area">
      <div class="temp-slot"></div>
      <div class="temp-slot"></div>
      <div class="temp-slot"></div>
      <div class="temp-slot"></div>
      <div class="temp-slot"></div>
      <div class="temp-slot"></div>
      <div class="temp-slot"></div>
    </div>
    <div id="tools-bar">
      <button id="undo-btn" disabled title="撤销(需兑换码)">↩️ 撤销 (<span id="undo-count">0</span>)</button>
      <button id="hint-btn" disabled title="提示(需兑换码)">💡 提示 (<span id="hint-count">0</span>)</button>
      <button id="shuffle-btn" disabled title="洗牌(需兑换码)">🔀 洗牌 (<span id="shuffle-count">0</span>)</button>
      <button id="restart-btn" title="重新开始当前关卡">🔄 重开</button>
    </div>
    <div id="code-bar">
      <input type="text" id="code-input" placeholder="兑换码" maxlength="12">
      <button id="code-btn">兑换</button>
    </div>
    <div id="message-bar"></div>
  </div>
  <div id="footer">
    喵了个咪 &copy 2025 | Designed by 开元
  </div>

  <div id="event-overlay">
      <div id="event-message-box">
          <div class="event-icon"></div>
          <p class="event-text"></p>
      </div>
  </div>

  <div id="start-screen">
    <video id="start-screen-video" autoplay loop muted playsinline>
      <source src="mao.webm" type="video/webm">
      <source src="mao.mp4" type="video/mp4">
      <img src="mao.webp" alt="背景图">
    </video>
    <h1><span>喵</span><span>了</span><span>个</span><span>咪</span><span> 🐾</span></h1>
    <p> </p> <p>
      <button class="start-btn" id="start-btn">开始游戏</button>
    </p>
    <p>收集卡牌，分数达标、全部清空过关<br>
    <span style="color:#c0392b;">第二关难度略有升级<br></span>可使用兑换码解锁道具</p>
    <small class="loading-footer">喵了个咪 &copy 2025 | Designed by 开元</small>
  </div>

  <div id="level2-outro-screen" style="display:none;">
    <video id="outro-video" playsinline muted>
        <source src="mao2.mp4" type="video/mp4">
        您的浏览器不支持视频播放。
    </video>
    <img id="outro-image" src="mao2.webp" alt="Level 2 Outro Image" style="display:none;">
    <div class="loading-text" style="display:none;">正在加载...</div>
    <button id="skip-outro-btn" style="display:none;">跳过动画</button>
  </div>

  <div id="level-finish" style="display:none;">
    <div id="netease-player" class="responsive-video-container" style="display:none;">
      <iframe allow="autoplay *; encrypted-media *; fullscreen *; clipboard-write" frameborder="0" height="450" style="width:100%;max-width:660px;overflow:hidden;border-radius:10px;" sandbox="allow-forms allow-popups allow-same-origin allow-scripts allow-storage-access-by-user-activation allow-top-navigation-by-user-activation" src="https://embed.music.apple.com/cn/playlist/favourite-music/pl.u-MDAWvoqtWXGMZrz"></iframe>
    </div>
    <div id="player" style="display:none;">
        <div id="player-content1">
            <div class="music-name"></div>
            <div class="artist-name"></div>
            <div class="time">
                <div class="current-time"></div>
                <div class="total-time"></div>
            </div>
            <div id="s-area">
                <div id="ins-time"></div>
                <div id="s-hover"></div>
                <div id="seek-bar"></div>
            </div>
        </div>
        <div id="player-content2">
            <div class="music-imgs">
                <div class="img"></div>
                <div id="buffer-box">缓冲,稍等...</div>
            </div>
            <div class="player-controls">
                <div class="btn prev iconfont"></div>
                <div class="btn play-pause icon-jiediankaishi iconfont"></div>
                <div class="btn next iconfont"></div>
            </div>
        </div>
    </div>
    <div id="level-finish-text"></div>
    <button id="next-btn">下一关</button>
    <button id="retry-btn" style="margin-left:10px;">重玩</button>
    <button id="gobang-btn" style="margin-left:10px; display:none;">五子棋对弈</button>
    <button id="restart-game-btn" style="margin-left:10px; display:none;">重开游戏</button>
    <button id="close-game-btn-level" style="margin-left:10px;">关闭游戏</button>
  </div>

  <div id="game-over" style="display:none;">
    <div id="game-over-text"></div>
    <button id="retry-btn2">重试</button>
    <button id="close-game-btn-gameover" style="margin-left:10px;">关闭游戏</button>
  </div>
</div>

<div id="confirm-modal" class="modal-overlay">
  <div class="modal-content">
    <p id="confirm-msg">你确定吗？</p>
    <div class="modal-buttons">
        <button id="confirm-yes">确定</button>
        <button id="confirm-no">取消</button>
    </div>
  </div>
</div>

<audio id="bgm" loop preload="auto">
  <source src="Get.mp3" type="audio/mpeg">
  <source src="Get.ogg" type="audio/ogg">
  您的浏览器不支持音频元素。
</audio>
<audio id="click-sound" src="kaa.mp3" preload="auto"></audio>

<script>
// 游戏配置常量
const CARD_ICONS = [
  "🐈", "💐", "🪼", "👒", "🏵️", "🧸", "🔮", "🎡", "🐈‍⬛", "🍫", "🪭",
  "🐖", "🧶", "🌻", "🦋"
];
const LEVELS = [
  {num: 1, visible: 18, total: 27, stack: 1, rows: 3, cols: 6, overlap: 15, targetScore: 25, totalDisplaySets: 5},
  {num: 2, visible: 18, total: 168, stack: 2, rows: 3, cols: 6, overlap: 15, targetScore: 100, totalDisplaySets: 20}
];
const TEMP_LIMIT = 7;
const DISPLAY_CARD_MATCH_SCORE = 5;
const INITIAL_DISPLAY_SETS_VISIBLE = 2;

const REDEMPTION_CODES = {
  "kaiyuan": { undo: 20, hint: 20, shuffle: 20 },
  "兑换码": { undo: 5, hint: 5, shuffle: 5 },
  "喵了个咪": { undo: 50, hint: 50, shuffle: 50 },
  "不知道": { undo: 3, hint: 1, shuffle: 1 },
  "开元": { undo: 10, hint: 10, shuffle: 10 },
  "通关": { type: "skip_level" }
};

// DOM 元素
const bgm = document.getElementById('bgm');
const confirmModal = document.getElementById('confirm-modal');
const confirmMsg = document.getElementById('confirm-msg');
const confirmYes = document.getElementById('confirm-yes');
const confirmNo = document.getElementById('confirm-no');
const footer = document.getElementById('footer');
const musicToggleBtn = document.getElementById('music-toggle');
const startBtn = document.getElementById('start-btn');
const nextBtn = document.getElementById('next-btn');
const retryBtnLevelFinish = document.getElementById('retry-btn');
const retryBtnGameOver = document.getElementById('retry-btn2');
const gobangBtn = document.getElementById('gobang-btn');
const restartGameBtn = document.getElementById('restart-game-btn');
const closeGameBtnLevel = document.getElementById('close-game-btn-level');
const closeGameBtnGameOver = document.getElementById('close-game-btn-gameover');
const undoBtn = document.getElementById('undo-btn');
const hintBtn = document.getElementById('hint-btn');
const shuffleBtn = document.getElementById('shuffle-btn');
const restartCurrentLevelBtn = document.getElementById('restart-btn');
const codeInput = document.getElementById('code-input');
const codeBtn = document.getElementById('code-btn');
const levelFinishTextElement = document.getElementById('level-finish-text');
const neteasePlayerDiv = document.getElementById('netease-player');
const playerDiv = document.getElementById('player');
const currentScoreElement = document.getElementById('current-score');
const targetScoreElement = document.getElementById('target-score');
const levelInfoElement = document.getElementById('level-info');
const displayArea = document.getElementById('display-area');
const cardStackArea = document.getElementById('card-stack-area');
const catPath = document.getElementById('cat-path');
const walkingCat = document.getElementById('walking-cat');
const wigglingCat1 = document.getElementById('wiggling-cat-1');
const wigglingCat4 = document.getElementById('wiggling-cat-4');
const wigglingCat7 = document.getElementById('wiggling-cat-7');
const level2OutroScreen = document.getElementById('level2-outro-screen');
const outroVideo = document.getElementById('outro-video');
const outroImage = document.getElementById('outro-image');
const outroLoadingText = level2OutroScreen.querySelector('.loading-text');
const skipOutroBtn = document.getElementById('skip-outro-btn');
const eventOverlay = document.getElementById('event-overlay');
const eventMessageBox = document.getElementById('event-message-box');
const eventIconEl = eventMessageBox.querySelector('.event-icon');
const eventTextEl = eventMessageBox.querySelector('.event-text');

let confirmCallback = null;
let outroVideoTimeout = null;
let randomEventTimer = null;

// 游戏状态对象
let game = {
  level: 1,
  cards: [],
  board: [],
  temp: [],
  matched: [],
  usedIcons: [],
  toolUses: {undo: 0, hint: 0, shuffle: 0},
  score: 0,
  targetScore: 0,
  displayCards: [],
  totalDisplaySetsGenerated: 0,
  progress: 0,
  stepStack: [],
  bgmOn: true,
  isNewLevel: false,
  lock: false,
  cardDimensions: { width: 0, height: 0, fontSize: 0, borderRadius: 0, borderWidth: 0 }
};

// 工具函数
function randArr(arr) {
  return arr.slice().sort(() => Math.random() - 0.5);
}

function shuffle(arr) {
  for (let i = arr.length - 1; i > 0; i--) {
    const j = Math.floor(Math.random() * (i + 1));
    [arr[i], arr[j]] = [arr[j], arr[i]];
  }
}

function deepClone(obj) {
  return JSON.parse(JSON.stringify(obj));
}

function randBetween(a, b) { return a + Math.random() * (b - a); }

function playBgm(on) {
  if (!bgm) return;
  if (on) {
    const playPromise = bgm.play();
    if (playPromise !== undefined) {
      playPromise.catch(error => {
        console.error("BGM 自动播放被阻止：", error);
        game.bgmOn = false;
        musicToggleBtn.innerHTML = '▶️';
      });
    }
  } else {
    bgm.pause();
  }
}

let clickSoundPool = [];
const MAX_CLICK_SOUNDS = 10;

function createClickSoundInstance() {
    const audio = new Audio();
    audio.preload = 'auto';
    audio.volume = 0.4;
    const mp3Source = document.createElement('source');
    mp3Source.src = 'kaa.mp3';
    mp3Source.type = 'audio/mpeg';
    audio.appendChild(mp3Source);
    const oggSource = document.createElement('source');
    oggSource.src = 'kaa.ogg';
    oggSource.type = 'audio/ogg';
    audio.appendChild(oggSource);
    audio.addEventListener('error', (e) => {
        console.error("Audio element error:", e);
    });
    return audio;
}

for (let i = 0; i < MAX_CLICK_SOUNDS; i++) {
    clickSoundPool.push(createClickSoundInstance());
}

function playClickSound() {
  if (game.bgmOn) {
    let soundInstance = clickSoundPool.find(audio => audio.paused || audio.ended);
    if (!soundInstance) {
        soundInstance = createClickSoundInstance();
    }
    soundInstance.currentTime = 0;
    soundInstance.play().catch(e => console.error("点击音效播放失败：", e));
  }
}

function showConfirm(msg, callback) {
  confirmMsg.textContent = msg;
  confirmCallback = callback;
  confirmModal.style.display = 'flex';
}

function hideConfirm() {
  confirmModal.style.display = 'none';
  confirmCallback = null;
}

confirmYes.onclick = () => {
  const callback = confirmCallback;
  hideConfirm();
  if (callback) {
    setTimeout(callback, 20);
  }
};
confirmNo.onclick = hideConfirm;

function generateDisplayCardSet(excludeIcons = []) {
    let chosenIcon = null;
    const clickableBoardCards = game.board.filter(c => !c.matched && isCardClickable(c, game.board));
    const clickableBoardIconCounts = {};
    clickableBoardCards.forEach(c => clickableBoardIconCounts[c.icon] = (clickableBoardIconCounts[c.icon] || 0) + 1);

    let potentialClickableIcons = Object.keys(clickableBoardIconCounts).filter(icon => !excludeIcons.includes(icon) && clickableBoardIconCounts[icon] >= 3);

    if (potentialClickableIcons.length > 0) {
        chosenIcon = potentialClickableIcons[Math.floor(Math.random() * potentialClickableIcons.length)];
    } else {
        const combinedClickableIcons = [...clickableBoardCards.map(c => c.icon), ...game.temp.map(c => c.icon)];
        const combinedClickableIconCounts = {};
        combinedClickableIcons.forEach(icon => combinedClickableIconCounts[icon] = (combinedClickableIconCounts[icon] || 0) + 1);
        let potentialCombinedIcons = Object.keys(combinedClickableIconCounts).filter(icon => !excludeIcons.includes(icon) && combinedClickableIconCounts[icon] >= 3);

        if (potentialCombinedIcons.length > 0) {
            chosenIcon = potentialCombinedIcons[Math.floor(Math.random() * potentialCombinedIcons.length)];
        } else {
            const allIconsInGame = game.cards.map(c => c.icon);
            const allIconCounts = {};
            allIconsInGame.forEach(icon => allIconCounts[icon] = (allIconCounts[icon] || 0) + 1);
            const anyTripletIcons = Object.keys(allIconCounts).filter(icon => !excludeIcons.includes(icon) && allIconCounts[icon] >= 3);

            if (anyTripletIcons.length > 0) {
                chosenIcon = anyTripletIcons[Math.floor(Math.random() * anyTripletIcons.length)];
            } else {
                const availableIconsWithoutExclusion = allIconsInGame.filter(icon => !excludeIcons.includes(icon));
                if (availableIconsWithoutExclusion.length > 0) {
                    chosenIcon = availableIconsWithoutExclusion[Math.floor(Math.random() * availableIconsWithoutExclusion.length)];
                } else if (allIconsInGame.length > 0) {
                    chosenIcon = allIconsInGame[Math.floor(Math.random() * allIconsInGame.length)];
                } else {
                    return null;
                }
            }
        }
    }

    if (chosenIcon) {
        return [
            { icon: chosenIcon, id: Date.now() + 1 },
            { icon: chosenIcon, id: Date.now() + 2 },
            { icon: chosenIcon, id: Date.now() + 3 }
        ];
    }
    return null;
}

function genLevel(levelIdx){
  const lv = LEVELS[levelIdx - 1];
  game.score = 0;
  game.targetScore = lv.targetScore;
  game.totalDisplaySetsGenerated = 0;

  let allIcons = [];
  const requiredUniqueIcons = Math.ceil(lv.total / 3);
  let availableIcons = randArr(CARD_ICONS).slice(0, Math.min(CARD_ICONS.length, requiredUniqueIcons + 2));

  let iconPool = [];
  for (let i = 0; i < requiredUniqueIcons; i++) {
    for (let j = 0; j < 3; j++) {
      iconPool.push(availableIcons[i % availableIcons.length]);
    }
  }
  while (iconPool.length < lv.total) {
      const remaining = lv.total - iconPool.length;
      if (remaining < 3) {
          for (let i = 0; i < remaining; i++) {
              iconPool.push(availableIcons[i % availableIcons.length]);
          }
      } else {
          const iconToAdd = availableIcons[Math.floor(Math.random() * availableIcons.length)];
          iconPool.push(iconToAdd, iconToAdd, iconToAdd);
      }
  }
  shuffle(iconPool);
  allIcons = iconPool;

  let cards = [];
  for(let i = 0; i < lv.total; i++){
    cards.push({ id: i, icon: allIcons[i], matched: false });
  }
  game.cards = cards;

  let board = [];
  const areaW = cardStackArea.offsetWidth;
  const areaH = cardStackArea.offsetHeight;

  const cardAspectRatio = 65 / 85;
  const minCardWidth = 50;
  const maxCardWidth = 80;
  const cardPadding = 10;
  const totalCards = lv.total;

  let estimatedCardArea = (areaW * areaH) / totalCards;
  let estimatedCardH = Math.sqrt(estimatedCardArea / cardAspectRatio);
  let estimatedCardW = estimatedCardH * cardAspectRatio;

  let finalCardW = estimatedCardW - cardPadding;
  let finalCardH = estimatedCardH - cardPadding;

  finalCardW = Math.max(minCardWidth, Math.min(finalCardW, maxCardWidth));
  finalCardH = finalCardW / cardAspectRatio;

  game.cardDimensions = {
      width: finalCardW,
      height: finalCardH,
      fontSize: finalCardW * 0.5, // Increased multiplier for better readability
      borderRadius: finalCardW * 0.15,
      borderWidth: finalCardW * 0.04
  };

  let stackDepth = lv.stack;
  const cardsPerStackLayer = Math.ceil(lv.total / stackDepth);
  const placementOverlapFactor = 0.9;
  let maxAttempts = 150;

  for (let cardIdx = 0; cardIdx < lv.total; cardIdx++) {
    const s = Math.min(Math.floor(cardIdx / cardsPerStackLayer), stackDepth - 1);
    let x = 0, y = 0;
    let foundPosition = false;
    for (let attempt = 0; attempt < maxAttempts; attempt++) {
      let tempX = randBetween(5, areaW - game.cardDimensions.width - 5);
      let tempY = randBetween(5, areaH - game.cardDimensions.height - 5);
      tempX += (s * 5 * (Math.random() - 0.5));
      tempY += (s * 5 * (Math.random() - 0.5));
      tempX = Math.max(5, Math.min(tempX, areaW - game.cardDimensions.width - 5));
      tempY = Math.max(5, Math.min(tempY, areaH - game.cardDimensions.height - 5));
      let overlap = false;
      for (const existingCard of board) {
        if (existingCard.stack <= s) {
          const dx = Math.abs(tempX - existingCard.x);
          const dy = Math.abs(tempY - existingCard.y);
          if (dx < game.cardDimensions.width * placementOverlapFactor && dy < game.cardDimensions.height * placementOverlapFactor) {
            overlap = true;
            break;
          }
        }
      }
      if (!overlap) {
        x = tempX;
        y = tempY;
        foundPosition = true;
        break;
      }
    }
    if (!foundPosition) {
        x = randBetween(5, areaW - game.cardDimensions.width - 5);
        y = randBetween(5, areaH - game.cardDimensions.height - 5);
    }
    const z = s * 1000 + cardIdx;
    board.push({
      id: cards[cardIdx].id, icon: cards[cardIdx].icon,
      x, y, z, matched: false, covered: false, stack: s, isNapping: false
    });
  }

  board.sort((a, b) => a.z - b.z);
  game.board = board;

  game.displayCards = [];
  const usedDisplayIconsForLevel = new Set();
  for (let i = 0; i < INITIAL_DISPLAY_SETS_VISIBLE; i++) {
      const newSet = generateDisplayCardSet(Array.from(usedDisplayIconsForLevel));
      if (newSet) {
          game.displayCards.push({ id: `display-set-${i}`, cards: newSet, matched: false });
          usedDisplayIconsForLevel.add(newSet[0].icon);
          game.totalDisplaySetsGenerated++;
      }
  }

  return {cards: game.cards, board: game.board, usedIcons: availableIcons.slice(0, Math.ceil(lv.total/3))};
}

function isCardClickable(card, board){
  if(card.matched || card.isNapping) return false;
  const activeCards = board.filter(c => !c.matched);
  const cardW = game.cardDimensions.width;
  const cardH = game.cardDimensions.height;
  const currentLevelConfig = LEVELS[game.level - 1];
  const clickableOverlapFactor = 1 - (currentLevelConfig.overlap / 100);
  const overlapThresholdX = cardW * clickableOverlapFactor;
  const overlapThresholdY = cardH * clickableOverlapFactor;

  for (const otherCard of activeCards) {
    if (card.id === otherCard.id) continue;
    if (otherCard.z > card.z) {
      const dx = Math.abs(otherCard.x - card.x);
      const dy = Math.abs(otherCard.y - card.y);
      if (dx < overlapThresholdX && dy < overlapThresholdY) {
        return false;
      }
    }
  }
  return true;
}

function clickCard(id) {
  if (game.lock) return;
  let cardData = game.board.find(c => c.id === id);
  if (!cardData || cardData.matched || !isCardClickable(cardData, game.board)) return;

  let tempCheck = [...game.temp, { icon: cardData.icon, id: cardData.id }];
  let iconCntCheck = {};
  tempCheck.forEach(c => iconCntCheck[c.icon] = (iconCntCheck[c.icon] || 0) + 1);
  let matchedIconCheck = Object.keys(iconCntCheck).find(k => iconCntCheck[k] === 3);

  if (game.temp.length >= TEMP_LIMIT && !matchedIconCheck) {
      gameOver('暂存区已满，游戏失败！');
      return;
  }

  saveStep();
  game.lock = true;

  const clickedCardEl = document.querySelector(`#card-stack-area .card[data-id='${id}']`);
  if (!clickedCardEl) {
    game.lock = false;
    return;
  }

  const startRect = clickedCardEl.getBoundingClientRect();
  const flyingCard = document.createElement('div');
  flyingCard.className = 'flying-card';
  flyingCard.innerHTML = cardData.icon;
  document.body.appendChild(flyingCard);
  flyingCard.style.left = `${startRect.left}px`;
  flyingCard.style.top = `${startRect.top}px`;
  flyingCard.style.width = `${startRect.width}px`;
  flyingCard.style.height = `${startRect.height}px`;
  flyingCard.style.fontSize = `${game.cardDimensions.fontSize}px`;
  flyingCard.style.borderRadius = `${game.cardDimensions.borderRadius}px`;
  flyingCard.style.borderWidth = `${game.cardDimensions.borderWidth}px`;

  clickedCardEl.style.opacity = '0';
  clickedCardEl.style.pointerEvents = 'none';
  playClickSound();

  const animationDuration = 150;
  const tempAppearanceDelay = 80;

  requestAnimationFrame(() => {
    const tempForPositionCalculation = [...game.temp, { icon: cardData.icon, id: cardData.id }];
    tempForPositionCalculation.sort((a, b) => a.icon.localeCompare(b.icon) || a.id - b.id);
    const endSlotIndex = tempForPositionCalculation.findIndex(c => c.id === id);
    const tempSlots = document.querySelectorAll('#temp-area .temp-slot');
    if (endSlotIndex < 0 || endSlotIndex >= tempSlots.length) {
        console.error("计算飞行卡片的结束槽索引无效。");
        document.body.removeChild(flyingCard);
        game.lock = false;
        return;
    }
    const endRect = tempSlots[endSlotIndex].getBoundingClientRect();
    const tempSlotStyle = window.getComputedStyle(tempSlots[endSlotIndex]);
    const flyingCardFinalWidth = parseFloat(tempSlotStyle.width) * 0.9;
    const flyingCardFinalHeight = parseFloat(tempSlotStyle.height) * 0.9;
    const destLeft = endRect.left + (endRect.width - flyingCardFinalWidth) / 2;
    const destTop = endRect.top + (endRect.height - flyingCardFinalHeight) / 2;
    flyingCard.style.left = `${destLeft}px`;
    flyingCard.style.top = `${destTop}px`;
    flyingCard.style.transform = `scale(${flyingCardFinalWidth / parseFloat(startRect.width)})`;
  });

  setTimeout(() => {
    if(document.body.contains(flyingCard)) document.body.removeChild(flyingCard);
  }, animationDuration);

  setTimeout(() => {
    cardData.matched = true;
    game.temp.push({ icon: cardData.icon, id: cardData.id, matched: false });
    game.temp.sort((a, b) => a.icon.localeCompare(b.icon) || a.id - b.id);
    renderTemp();
    renderBoard();
    renderProgressAndScore();
    updateWigglingCatVisibility();

    let iconCnt = {};
    game.temp.forEach(c => { if (!c.matched) iconCnt[c.icon] = (iconCnt[c.icon] || 0) + 1; });
    let matchedIcon = Object.keys(iconCnt).find(k => iconCnt[k] === 3);

    if (matchedIcon) {
      game.temp.forEach(c => { if (c.icon === matchedIcon) c.matched = true; });
      game.displayCards.forEach(displaySet => {
          if (!displaySet.matched && displaySet.cards[0].icon === matchedIcon) {
              displaySet.matched = true;
              game.score += DISPLAY_CARD_MATCH_SCORE;
              renderProgressAndScore();
              const matchedDisplayGroupEl = document.querySelector(`#display-area .display-group[data-id='${displaySet.id}']`);
              if (matchedDisplayGroupEl) {
                  const groupRect = matchedDisplayGroupEl.getBoundingClientRect();
                  const scoreAnimDiv = document.createElement('div');
                  scoreAnimDiv.className = 'score-animation';
                  scoreAnimDiv.textContent = `+${DISPLAY_CARD_MATCH_SCORE}`;
                  document.body.appendChild(scoreAnimDiv);
                  scoreAnimDiv.style.left = `${groupRect.left + groupRect.width / 2}px`;
                  scoreAnimDiv.style.top = `${groupRect.top + groupRect.height / 2}px`;
                  scoreAnimDiv.style.transform = 'translate(-50%, -50%)';
                  scoreAnimDiv.addEventListener('animationend', () => scoreAnimDiv.remove(), { once: true });
              }
              setTimeout(() => {
                  const newSet = generateDisplayCardSet(game.displayCards.map(ds => ds.cards[0].icon));
                  if (newSet) {
                      displaySet.cards = newSet;
                      displaySet.matched = false;
                      game.totalDisplaySetsGenerated++;
                  } else {
                      game.displayCards = game.displayCards.filter(ds => ds.id !== displaySet.id);
                  }
                  renderDisplay();
              }, 400);
          }
      });
      setTimeout(() => {
        game.temp = game.temp.filter(c => !c.matched);
        renderTemp();
        renderBoard();
        checkWin();
        game.lock = false;
      }, 100);
    } else {
      checkWin();
      game.lock = false;
    }
  }, tempAppearanceDelay);
}

function checkWin(){
  const allCardsMatched = game.board.every(c=>c.matched);
  const scoreMet = game.score >= game.targetScore;

  if(allCardsMatched && scoreMet){
    stopRandomEvents();
    setTimeout(()=>{
      if(game.level===1){
        showLevelFinish('恭喜恭喜！第一关通关！');
      }else{
        playLevel2Outro();
      }
    },330);
  } else if (allCardsMatched && !scoreMet) {
      gameOver(`卡牌已全部消除，但分数未达标！<br>当前分数: ${game.score} / 目标分数: ${game.targetScore}`);
  }
}

function saveStep(){
  game.stepStack.push({
    board: deepClone(game.board),
    temp: deepClone(game.temp),
    score: game.score,
    displayCards: deepClone(game.displayCards),
    totalDisplaySetsGenerated: game.totalDisplaySetsGenerated
  });
  if(game.stepStack.length > 20) game.stepStack.shift();
}

function undoStep(){
  if(game.stepStack.length > 0){
    let prev = game.stepStack.pop();
    game.board = deepClone(prev.board);
    game.temp = deepClone(prev.temp);
    game.score = prev.score;
    game.displayCards = deepClone(prev.displayCards);
    game.totalDisplaySetsGenerated = prev.totalDisplaySetsGenerated;
    renderAll();
    showMessage('已撤销');
    updateWigglingCatVisibility();
  } else {
    showMessage('无法撤销更多', '#888');
  }
}

function shuffleStep(){
  saveStep();
  game.lock = true;
  document.querySelectorAll('#card-stack-area .card:not(.matched)').forEach(el => {
      el.classList.add('card-shuffling-out');
  });
  setTimeout(() => {
      let unmatched = game.board.filter(c=>!c.matched);
      let icons = unmatched.map(c=>c.icon);
      shuffle(icons);
      unmatched.forEach((c,i)=>{ c.icon = icons[i]; });
      renderAll();
      showMessage('已洗牌');
      game.lock = false;
      updateWigglingCatVisibility();
  }, 300);
}

function hintStep(){
  let tempIcons = game.temp.map(c => c.icon);
  let clickableBoardCards = game.board.filter(c => !c.matched && isCardClickable(c, game.board));
  let clickableBoardIcons = clickableBoardCards.map(c => c.icon);
  let allAvailableIcons = [...tempIcons, ...clickableBoardIcons];
  let iconCounts = {};
  allAvailableIcons.forEach(icon => { iconCounts[icon] = (iconCounts[icon] || 0) + 1; });
  let targetIcon = Object.keys(iconCounts).find(icon => iconCounts[icon] >= 3);

  document.querySelectorAll('.hinted-shake').forEach(el => el.classList.remove('hinted-shake'));

  if (targetIcon) {
    let hintDone = 0;
    const tempSlots = document.querySelectorAll('#temp-area .temp-slot');
    const hintedElements = [];

    for (let i = 0; i < game.temp.length && hintDone < 3; i++) {
      if (game.temp[i].icon === targetIcon && !game.temp[i].matched) {
        const tempCardElement = tempSlots[i].querySelector('.temp-card');
        if (tempCardElement) {
          tempCardElement.classList.add('hinted-shake');
          hintedElements.push(tempCardElement);
          hintDone++;
        }
      }
    }
    for (let i = 0; i < clickableBoardCards.length && hintDone < 3; i++) {
      let boardCard = clickableBoardCards[i];
      if (boardCard.icon === targetIcon) {
        let doms = document.querySelector(`#card-stack-area .card[data-id='${boardCard.id}']`);
        if (doms) {
          doms.classList.add('hinted-shake');
          hintedElements.push(doms);
          hintDone++;
        }
      }
    }
    showMessage('已提示可消除三张');
    setTimeout(() => {
        hintedElements.forEach(el => el.classList.remove('hinted-shake'));
    }, 2000); // Animation duration is 0.5s * 4 iterations
  } else {
    showMessage('当前无可三消', "#888");
  }
}

function gameOver(msg){
  stopRandomEvents();
  game.lock = true;
  document.getElementById('card-stack-area').innerHTML = '';
  document.querySelectorAll('#temp-area .temp-slot').forEach(slot => { slot.innerHTML = ''; });
  displayArea.innerHTML = '';
  document.getElementById('level-info').textContent = '';
  currentScoreElement.textContent = '0';
  targetScoreElement.textContent = '0';
  document.getElementById('message-bar').textContent = '';
  hideWigglingCats();
  setTimeout(() => {
    document.getElementById('game-over').style.display = 'flex';
    document.getElementById('game-over-text').innerHTML = msg;
  }, 100);
}

function startGame(level){
  footer.style.display = 'block';
  game.level = level;
  let lvData = genLevel(level);
  game.cards = lvData.cards;
  game.board = lvData.board;
  game.usedIcons = lvData.usedIcons;
  game.temp = [];
  game.matched = [];
  game.toolUses = {undo: 0, hint: 0, shuffle: 0};
  game.stepStack = [];
  game.lock = false;
  game.isNewLevel = true;
  renderAll();
  updateToolButtons();
  if (game.bgmOn) playBgm(true);
  positionCatWalker();
  updateWigglingCatVisibility();
  startRandomEvents();
}

function renderBoard(){
  const area = document.getElementById('card-stack-area');
  area.innerHTML = '';
  let cardsToRender = game.board.filter(c => !c.matched);
  cardsToRender.sort((a, b) => a.z - b.z);
  const isInitialRenderForLevel = game.isNewLevel;

  cardsToRender.forEach((card, index) => {
    let el = document.createElement('div');
    const clickable = isCardClickable(card, game.board);
    el.className = "card" + (clickable ? "" : " disabled");
    if (card.isNapping) el.classList.add('napping');
    el.style.left = card.x + 'px';
    el.style.top = card.y + 'px';
    el.style.zIndex = card.z;
    el.innerHTML = card.icon;
    el.dataset.id = card.id;
    el.style.width = `${game.cardDimensions.width}px`;
    el.style.height = `${game.cardDimensions.height}px`;
    el.style.fontSize = `${game.cardDimensions.fontSize}px`;
    el.style.borderRadius = `${game.cardDimensions.borderRadius}px`;
    el.style.borderWidth = `${game.cardDimensions.borderWidth}px`;
    if(clickable) el.onclick = () => clickCard(card.id);
    if (isInitialRenderForLevel) {
        el.classList.add('card-entering');
        el.style.animationDelay = `${index * 0.03}s`;
        el.addEventListener('animationend', function handler() {
            el.classList.remove('card-entering');
            el.style.animationDelay = '';
            el.removeEventListener('animationend', handler);
        }, { once: true });
    }
    area.appendChild(el);
  });
  game.isNewLevel = false;
}

function renderTemp(){
  const tempSlots = document.querySelectorAll('#temp-area .temp-slot');
  const tempArea = document.getElementById('temp-area');
  const tempCardScaleFactor = 0.8;
  const tempCardWidth = game.cardDimensions.width * tempCardScaleFactor;
  const tempCardHeight = game.cardDimensions.height * tempCardScaleFactor;
  const tempCardFontSize = game.cardDimensions.fontSize * tempCardScaleFactor;
  const tempCardBorderRadius = game.cardDimensions.borderRadius * tempCardScaleFactor;
  const tempCardBorderWidth = game.cardDimensions.borderWidth * tempCardScaleFactor;
  tempArea.style.minHeight = `${tempCardHeight + (tempCardBorderWidth * 2) + 16}px`;

  tempSlots.forEach((slot, i) => {
    slot.innerHTML = '';
    slot.style.width = `${tempCardWidth}px`;
    slot.style.height = `${tempCardHeight}px`;
    slot.style.borderRadius = `${tempCardBorderRadius}px`;
    slot.style.borderWidth = `${tempCardBorderWidth}px`;
    slot.style.margin = '0';

    if (i < game.temp.length) {
      const c = game.temp[i];
      let el = document.createElement('div');
      el.className = "temp-card" + (c.matched ? " matched" : "");
      el.innerHTML = c.icon;
      el.style.fontSize = `${tempCardFontSize}px`;
      el.style.borderRadius = `${tempCardBorderRadius}px`;
      el.style.borderWidth = `${tempCardBorderWidth}px`;
      slot.appendChild(el);
    }
  });

  let persistentHeart = document.getElementById('persistent-heart');
  if (game.temp.length === 7) {
    const seventhTempSlot = tempSlots[6];
    if (seventhTempSlot) {
      const mainArea = document.getElementById('main-area');
      const cardStackArea = document.getElementById('card-stack-area');
      const seventhSlotRect = seventhTempSlot.getBoundingClientRect();
      const cardStackRect = cardStackArea.getBoundingClientRect();
      const mainAreaRect = mainArea.getBoundingClientRect();
      const heartVerticalMidpointAbsolute = cardStackRect.bottom + (seventhSlotRect.top - cardStackRect.bottom) / 2;
      const heartTopRelativeToMainArea = heartVerticalMidpointAbsolute - mainAreaRect.top;
      const heartLeftRelativeToMainArea = (seventhTempSlot.left + seventhTempSlot.offsetWidth / 2) - mainAreaRect.left;
      if (!persistentHeart) {
        persistentHeart = document.createElement('div');
        persistentHeart.id = 'persistent-heart';
        persistentHeart.className = 'heart-animation';
        persistentHeart.innerHTML = '💝';
        mainArea.appendChild(persistentHeart);
      }
      persistentHeart.style.left = `${heartLeftRelativeToMainArea}px`;
      persistentHeart.style.top = `${heartTopRelativeToMainArea}px`;
      persistentHeart.style.transform = 'translate(-50%, -50%)';
      persistentHeart.style.display = 'block';
    }
  } else {
    if (persistentHeart) persistentHeart.style.display = 'none';
  }
}

function renderDisplay() {
    displayArea.innerHTML = '';
    const displayCardWidth = game.cardDimensions.width * 0.7;
    const displayCardHeight = game.cardDimensions.height * 0.7;
    const displayCardFontSize = game.cardDimensions.fontSize * 0.7;
    const displayCardBorderRadius = game.cardDimensions.borderRadius * 0.7;
    const displayCardBorderWidth = game.cardDimensions.borderWidth * 0.7;
    const displayGroupGap = displayCardWidth * 0.1;
    displayArea.style.width = `${cardStackArea.offsetWidth * 0.95}px`;
    displayArea.style.minHeight = `${displayCardHeight + displayCardBorderWidth * 2 + 20}px`;

    game.displayCards.forEach(displaySet => {
        const groupDiv = document.createElement('div');
        groupDiv.className = 'display-group';
        groupDiv.dataset.id = displaySet.id;
        groupDiv.style.gap = `${displayGroupGap}px`;
        displaySet.cards.forEach(card => {
            const cardDiv = document.createElement('div');
            cardDiv.className = 'display-card' + (displaySet.matched ? ' matched-display' : '');
            cardDiv.innerHTML = card.icon;
            cardDiv.style.width = `${displayCardWidth}px`;
            cardDiv.style.height = `${displayCardHeight}px`;
            cardDiv.style.fontSize = `${displayCardFontSize}px`;
            cardDiv.style.borderRadius = `${displayCardBorderRadius}px`;
            cardDiv.style.borderWidth = `${displayCardBorderWidth}px`;
            groupDiv.appendChild(cardDiv);
        });
        displayArea.appendChild(groupDiv);
    });
}

function renderProgressAndScore(){
  levelInfoElement.textContent = `关卡: ${game.level} / 2`;
  currentScoreElement.textContent = game.score;
  targetScoreElement.textContent = game.targetScore;
  updateWigglingCatVisibility();
}

function showMessage(msg, color){
  let bar = document.getElementById('message-bar');
  bar.style.color = color || '#c0392b';
  bar.textContent = msg || '';
  if(msg) setTimeout(()=>{bar.textContent='';}, 2300);
}

function updateToolButtons() {
  document.getElementById('undo-count').textContent = game.toolUses.undo;
  document.getElementById('hint-count').textContent = game.toolUses.hint;
  document.getElementById('shuffle-count').textContent = game.toolUses.shuffle;
  undoBtn.disabled = game.toolUses.undo <= 0;
  hintBtn.disabled = game.toolUses.hint <= 0;
  shuffleBtn.disabled = game.toolUses.shuffle <= 0;
}

function renderAll(){
  renderBoard();
  renderTemp();
  renderDisplay();
  renderProgressAndScore();
  updateToolButtons();
  positionCatWalker();
  updateWigglingCatVisibility();
}

function showLevelFinish(msg){
  stopRandomEvents();
  playBgm(false);
  if (outroVideoTimeout) clearTimeout(outroVideoTimeout);
  if (outroVideo) { outroVideo.pause(); outroVideo.currentTime = 0; }
  level2OutroScreen.style.display = 'none';
  skipOutroBtn.style.display = 'none';
  game.lock = false;
  document.getElementById('level-finish').style.display='flex';
  levelFinishTextElement.innerHTML = msg;
  nextBtn.style.display = (game.level === 1) ? 'inline-block' : 'none';

  if (game.level === 1) {
    levelFinishTextElement.style.animation = 'shake 3s infinite, show-card-property 6s forwards';
    levelFinishTextElement.innerHTML += '<br>下一关后有彩蛋🪅！';
    playerDiv.style.display = 'block';
    neteasePlayerDiv.style.display = 'none';
    gobangBtn.style.display = 'none';
    restartGameBtn.style.display = 'none';
    retryBtnLevelFinish.style.display = 'inline-block';
  } else if (game.level === 2) {
    levelFinishTextElement.style.animation = 'pulse-scale 2s infinite alternate, wave 2s infinite';
    playerDiv.style.display = 'none';
    neteasePlayerDiv.style.display = 'block';
    gobangBtn.style.display = 'inline-block';
    restartGameBtn.style.display = 'inline-block';
    retryBtnLevelFinish.style.display = 'none';
  }
}

function initializeGame(){
  musicToggleBtn.innerHTML = game.bgmOn ? '🎼' : '🔇';
  updateToolButtons();
  if (bgm) bgm.volume = 0.3;
}

function handleCloseGame(type) {
    showConfirm('确定要关闭游戏吗？', () => {
        window.close();
        setTimeout(() => {
            document.getElementById('game-container').style.display = 'none';
            let messageHtml = type === 'level' ? `
                    <p>当前客户端暂不支持自动关闭，</p><p>请点击页面关闭标签关闭。</p>
                    <br> 如若重新开始游戏，请点击<br><br>
                    <button onclick="window.location.href='https://kaiyuanzhuadmin.github.io/cat/'"
                            style="padding: 10px 20px; border: 1px solid #dc2626; background-color: #fef2f2; cursor: pointer; border-radius: 0.375rem; color: #dc2626; font-weight: 500;">
                      重新开始
                    </button>` : `
                    <p>当前客户端暂不支持自动关闭</p><p>小提示：可输入"kaiyuan"兑换提示次数。</p>
                    <br> 如果想重新开始游戏，请点击<br><br>
                    <button onclick="window.location.href='https://kaiyuanzhuadmin.github.io/cat/'"
                            style="padding: 10px 20px; border: 1px solid #dc2626; background-color: #fef2f2; cursor: pointer; border-radius: 0.375rem; color: #dc2626; font-weight: 500;">
                      重新开始
                    </button>`;
            document.body.innerHTML = `
                <div style="display:flex; flex-direction:column; align-items:center; justify-content:center; height:60vh; font-size:1.2em; color:#5d4037; text-align:center;">
                  ${messageHtml}
                  <br>
                  <small class="loading-footer" style="position: static; margin-top: 2rem;">喵了个咪 &copy 2025 | Designed by 开元</small>
                </div>`;
        }, 100);
    });
}

// Random Event Logic
function showEventMessage(icon, text) {
    eventIconEl.textContent = icon;
    eventTextEl.innerHTML = text;
    eventOverlay.style.display = 'flex';
    setTimeout(() => { eventOverlay.style.display = 'none'; }, 3500);
}
function eventCatNap() {
    const clickableCards = game.board.filter(c => isCardClickable(c, game.board));
    if (clickableCards.length < 3) return;
    showEventMessage('💤', '猫咪在打盹...<br>有些卡牌暂时拿不到了！');
    game.lock = true;
    const nappingCards = [];
    const centerCard = clickableCards[Math.floor(Math.random() * clickableCards.length)];
    nappingCards.push(centerCard);
    const otherCards = game.board.filter(c => !c.matched && c.id !== centerCard.id);
    otherCards.sort((a, b) => Math.hypot(a.x - centerCard.x, a.y - centerCard.y) - Math.hypot(b.x - centerCard.x, b.y - centerCard.y));
    nappingCards.push(...otherCards.slice(0, Math.floor(Math.random() * 2) + 2));
    nappingCards.forEach(card => card.isNapping = true);
    renderBoard();
    game.lock = false;
    setTimeout(() => {
        nappingCards.forEach(card => {
            const boardCard = game.board.find(c => c.id === card.id);
            if (boardCard) boardCard.isNapping = false;
        });
        renderBoard();
    }, 10000);
}
function eventCuriousPaw() {
    const clickableCards = game.board.filter(c => isCardClickable(c, game.board));
    const unclickableCards = game.board.filter(c => !c.matched && !isCardClickable(c, game.board));
    if (clickableCards.length === 0 || unclickableCards.length === 0) return;
    showEventMessage('🐾', '好奇的爪子...<br>一张可见卡牌和一张不可见卡牌的图标被交换了！');
    game.lock = true;
    const card1 = clickableCards[Math.floor(Math.random() * clickableCards.length)];
    const card2 = unclickableCards[Math.floor(Math.random() * unclickableCards.length)];
    [card1.icon, card2.icon] = [card2.icon, card1.icon];
    const card1El = document.querySelector(`.card[data-id='${card1.id}']`);
    const card2El = document.querySelector(`.card[data-id='${card2.id}']`);
    if (card1El) card1El.classList.add('hinted-shake');
    if (card2El) card2El.classList.add('hinted-shake');
    setTimeout(() => {
        renderBoard();
        game.lock = false;
    }, 800);
}
function eventGiftOffering() {
    const tools = ['undo', 'hint', 'shuffle'];
    const toolNames = { undo: '撤销', hint: '提示', shuffle: '洗牌' };
    const randomTool = tools[Math.floor(Math.random() * tools.length)];
    game.toolUses[randomTool]++;
    updateToolButtons();
    showEventMessage('🎁', `猫咪送来了礼物！<br>获得1次免费<b>${toolNames[randomTool]}</b>！`);
}
const randomEvents = [
    { name: 'catNap', func: eventCatNap, weight: 3 },
    { name: 'curiousPaw', func: eventCuriousPaw, weight: 3 },
    { name: 'giftOffering', func: eventGiftOffering, weight: 2 }
];
function startRandomEvents() {
    stopRandomEvents();
    randomEventTimer = setInterval(() => {
        if (game.lock || document.getElementById('level-finish').style.display === 'flex' || document.getElementById('game-over').style.display === 'flex') return;
        const weightedList = [];
        randomEvents.forEach(event => {
            for (let i = 0; i < event.weight; i++) weightedList.push(event.func);
        });
        const randomEventFunc = weightedList[Math.floor(Math.random() * weightedList.length)];
        randomEventFunc();
    }, randBetween(20000, 30000));
}
function stopRandomEvents() {
    if (randomEventTimer) clearInterval(randomEventTimer);
    randomEventTimer = null;
}

// Event Listeners
document.addEventListener('DOMContentLoaded', function() {
    initializeLoadingScreen();
    attemptVideoAutoplay();
    const feedbackDiv = document.createElement('div');
    feedbackDiv.style.cssText = 'color: red; font-size: 12px; margin-top: 5px;';
    codeInput.parentNode.insertBefore(feedbackDiv, codeInput.nextSibling);
    codeInput.addEventListener('input', function() {
        const code = codeInput.value.trim();
        feedbackDiv.textContent = '';
        codeInput.style.borderColor = '';
        const codeRegex = /^[\u4e00-\u9fa5a-zA-Z0-9]*$/;
        if (code.length === 7) {
            if (codeRegex.test(code)) {
                feedbackDiv.textContent = '字符数正确';
                feedbackDiv.style.color = 'green';
                codeInput.style.borderColor = 'green';
                codeBtn.disabled = false;
                codeBtn.click();
            } else {
                feedbackDiv.textContent = '兑换码包含不支持的字符';
                feedbackDiv.style.color = 'red';
                codeInput.style.borderColor = 'red';
                codeBtn.disabled = true;
            }
        } else if (code.length < 7) {
            feedbackDiv.textContent = `还可输入 ${7 - code.length} 位`;
            feedbackDiv.style.color = 'orange';
            codeInput.style.borderColor = 'orange';
            codeBtn.disabled = true;
        } else {
            codeBtn.disabled = true;
        }
    });
    codeBtn.addEventListener('click', function() {
       codeInput.value = '';
       feedbackDiv.textContent = '';
       codeInput.style.borderColor = '';
       codeBtn.disabled = true;
    });
    codeInput.addEventListener('keyup', e => { if (e.key === 'Enter' && !codeBtn.disabled) codeBtn.click(); });
    window.addEventListener('resize', () => {
        if (game.level) {
            let tempBoard = genLevel(game.level);
            game.board = tempBoard.board;
            renderAll();
        }
    });
    skipOutroBtn.addEventListener('click', () => showLevelFinish('<p> <br> </p>所有关卡全部通关！<br> 🎉 你太棒啦！🎉'));
    if (walkingCat) {
        walkingCat.style.transform = 'scaleX(-1)';
        walkingCat.addEventListener('animationiteration', () => {
            const currentTransform = window.getComputedStyle(walkingCat).transform;
            walkingCat.style.transform = currentTransform.includes('matrix(-1,') ? 'scaleX(1)' : 'scaleX(-1)';
            walkingCat.style.opacity = '0';
            setTimeout(() => { walkingCat.style.opacity = '1'; }, 10);
        });
    }
});

undoBtn.onclick = function(){ if(game.toolUses.undo > 0 && game.stepStack.length > 0){ undoStep(); game.toolUses.undo--; updateToolButtons(); } };
hintBtn.onclick = function(){ if(game.toolUses.hint > 0){ hintStep(); game.toolUses.hint--; updateToolButtons(); } };
shuffleBtn.onclick = function(){ if(game.toolUses.shuffle > 0){ shuffleStep(); game.toolUses.shuffle--; updateToolButtons(); } };
restartCurrentLevelBtn.onclick = () => showConfirm('确定要重新开始当前关卡吗？', () => { stopRandomEvents(); startGame(game.level); showMessage('关卡已重新开始！', '#3e5a2b'); });
codeBtn.onclick = function(){
  let val = codeInput.value.trim().toLowerCase();
  const rewards = REDEMPTION_CODES[val];
  if (rewards) {
    if (rewards.type === "skip_level") {
      game.board.forEach(card => card.matched = true);
      game.score = game.targetScore;
      renderBoard();
      renderProgressAndScore();
      checkWin();
      showMessage(`兑换成功！当前关卡已跳过！`, "#3e5a2b");
    } else {
      game.toolUses.undo += rewards.undo || 0;
      game.toolUses.hint += rewards.hint || 0;
      game.toolUses.shuffle += rewards.shuffle || 0;
      showMessage(`兑换成功！获得撤销x${rewards.undo}, 提示x${rewards.hint}, 洗牌x${rewards.shuffle}`, "#3e5a2b");
    }
    updateToolButtons();
  } else {
    showMessage('兑换码错误', "#c0392b");
  }
  codeInput.value = '';
};
musicToggleBtn.onclick = function(){ game.bgmOn = !game.bgmOn; this.innerHTML = game.bgmOn ? '🎼' : '🔇'; playBgm(game.bgmOn); };
startBtn.onclick = function(){ document.getElementById('start-screen').style.display = 'none'; startGame(1); };
nextBtn.onclick = function(){ document.getElementById('level-finish').style.display = 'none'; startGame(2); };
retryBtnLevelFinish.onclick = function(){ document.getElementById('level-finish').style.display = 'none'; startGame(game.level); };
retryBtnGameOver.onclick = function(){ document.getElementById('game-over').style.display = 'none'; startGame(game.level); };
gobangBtn.onclick = () => window.open('https://kaiyuanzhuadmin.github.io/kaiyuan/', '_blank');
restartGameBtn.onclick = () => window.location.href = 'https://kaiyuanzhuadmin.github.io/cat/';
closeGameBtnLevel.onclick = () => handleCloseGame('level');
closeGameBtnGameOver.onclick = () => handleCloseGame('gameover');

function initializeLoadingScreen() {
    const loadingScreen = document.getElementById('loading-screen');
    const progressBar = document.getElementById('progress-bar');
    const loadingText = document.getElementById('loading-text');
    let progress = 0;
    const assets = ["加载字体...", "加载音效...", "加载图片...", "初始化关卡...", "准备喵咪...", "完成!"];
    let assetIndex = 0;
    loadingText.textContent = assets[0];
    const interval = setInterval(() => {
        progress += Math.random() * 15 + 5;
        if (progress >= 100) {
            progress = 100;
            clearInterval(interval);
            progressBar.style.width = progress + '%';
            loadingText.textContent = assets[assets.length - 1];
            setTimeout(() => {
                loadingScreen.style.opacity = '0';
                loadingScreen.addEventListener('transitionend', () => {
                    loadingScreen.style.display = 'none';
                    document.title = "喵了个咪";
                    initializeGame();
                }, { once: true });
            }, 400);
        } else {
            progressBar.style.width = progress + '%';
            const nextAssetThreshold = (assetIndex + 1) * 20;
            if (progress > nextAssetThreshold && assetIndex < assets.length - 1) {
                assetIndex++;
                loadingText.textContent = assets[assetIndex];
            }
        }
    }, 250);
}
function attemptVideoAutoplay() {
    const video = document.getElementById('start-screen-video');
    if (!video) return;
    const playPromise = video.play();
    if (playPromise !== undefined) {
        playPromise.catch(error => {
            console.log("视频直接播放失败，等待用户交互或微信JSBridgeReady事件。", error);
            document.body.addEventListener('touchstart', function onFirstTouch() {
                video.play().catch(e => console.error("触摸后视频播放失败:", e));
                document.body.removeEventListener('touchstart', onFirstTouch);
            }, { once: true });
        });
    }
    if (typeof WeixinJSBridge == "object" && typeof WeixinJSBridge.invoke == "function") {
        WeixinJSBridge.invoke('getNetworkType', {}, e => video.play().catch(err => console.error("微信JSBridge准备好后视频播放失败:", err)));
    } else {
        document.addEventListener("WeixinJSBridgeReady", () => WeixinJSBridge.invoke('getNetworkType', {}, e => video.play().catch(err => console.error("WeixinJSBridgeReady事件触发后视频播放失败:", err))), false);
    }
}

function positionCatWalker() {
    const displayArea = document.getElementById('display-area');
    const catPath = document.getElementById('cat-path');
    const mainArea = document.getElementById('main-area');
    if (!displayArea || !catPath || !mainArea) return;
    const displayAreaBottomRelativeToMainArea = displayArea.offsetTop + displayArea.offsetHeight;
    catPath.style.top = `${displayAreaBottomRelativeToMainArea}px`;
    catPath.style.width = `${mainArea.offsetWidth}px`;
}

function positionWigglingCat(wigglingCatEl, slotIndex) {
    const tempSlots = document.querySelectorAll('#temp-area .temp-slot');
    const cardStackArea = document.getElementById('card-stack-area');
    const mainArea = document.getElementById('main-area');
    if (!wigglingCatEl || tempSlots.length === 0 || !cardStackArea || !mainArea || slotIndex < 0 || slotIndex >= tempSlots.length) {
        if (wigglingCatEl) wigglingCatEl.style.display = 'none';
        return;
    }
    const targetTempSlot = tempSlots[slotIndex];
    const cardStackRect = cardStackArea.getBoundingClientRect();
    const targetTempSlotRect = targetTempSlot.getBoundingClientRect();
    const mainAreaRect = mainArea.getBoundingClientRect();
    const gapMidpointAbsolute = cardStackRect.bottom + (targetTempSlotRect.top - cardStackRect.bottom) / 2;
    const topRelativeToMainArea = gapMidpointAbsolute - mainAreaRect.top;
    const leftRelativeToMainArea = (targetTempSlotRect.left + targetTempSlot.offsetWidth / 2) - mainAreaRect.left;
    wigglingCatEl.style.top = `${topRelativeToMainArea - (wigglingCatEl.offsetHeight / 2)}px`;
    wigglingCatEl.style.left = `${leftRelativeToMainArea}px`;
    wigglingCatEl.style.display = 'block';
}

function hideWigglingCats() {
    wigglingCat1.style.display = 'none';
    wigglingCat4.style.display = 'none';
    wigglingCat7.style.display = 'none';
}

function updateWigglingCatVisibility() {
    if (game.score >= game.targetScore) {
        positionWigglingCat(wigglingCat1, 0);
        positionWigglingCat(wigglingCat4, 3);
        positionWigglingCat(wigglingCat7, 6);
    } else {
        hideWigglingCats();
    }
}

function playLevel2Outro() {
    game.lock = true;
    playBgm(false);
    level2OutroScreen.style.display = 'flex';
    outroLoadingText.style.display = 'block';
    skipOutroBtn.style.display = 'block';
    outroVideo.style.display = 'none';
    outroImage.style.display = 'none';
    outroVideoTimeout = setTimeout(() => {
        outroVideo.style.display = 'none';
        outroImage.style.display = 'block';
        outroLoadingText.textContent = '视频无法播放，显示图片...';
        setTimeout(() => showLevelFinish('<p> <br> </p>所有关卡全部通关！<br> 🎉 你太棒啦！🎉'), 3000);
    }, 7000);
    outroVideo.load();
    const playPromise = outroVideo.play();
    if (playPromise !== undefined) {
        playPromise.then(() => {
            outroVideo.style.display = 'block';
            outroLoadingText.style.display = 'none';
            if (outroVideoTimeout) clearTimeout(outroVideoTimeout);
        }).catch(error => {
            outroVideo.style.display = 'none';
            outroImage.style.display = 'block';
            outroLoadingText.textContent = '视频无法播放，显示图片...';
            if (outroVideoTimeout) clearTimeout(outroVideoTimeout);
            setTimeout(() => showLevelFinish('<p> <br> </p>所有关卡全部通关！<br> 🎉 你太棒啦！🎉'), 3000);
        });
    }
    outroVideo.onended = () => {
        if (outroVideoTimeout) clearTimeout(outroVideoTimeout);
        showLevelFinish('<p> <br> </p>所有关卡全部通关！<br> 🎉 你太棒啦！🎉');
    };
    outroVideo.onerror = (e) => {
        if (outroVideoTimeout) clearTimeout(outroVideoTimeout);
        outroVideo.style.display = 'none';
        outroImage.style.display = 'block';
        outroLoadingText.textContent = '视频加载失败，显示图片...';
        setTimeout(() => showLevelFinish('<p> <br> </p>所有关卡全部通关！<br> 🎉 你太棒啦！🎉'), 3000);
    };
}
</script>
</body>
</html>
